<!DOCTYPE html>
<html lang="en" class="yui-overrride">
<head>
    <meta charset="utf-8">
    <title>app\client\admin\js\ovManage\DeviceFactory.js - OpenVeo Manage AngularJS back end</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700' rel='stylesheet' type='text/css'>
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1 class="blue-main-title">OpenVeo Manage AngularJS back end</h1>
        </div>
        <div class="yui3-u-1-4 version project-version">
            API Docs for: 1.0.0
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ManageDeviceFactory.html">ManageDeviceFactory</a></li>
                                <li><a href="../classes/ManageFactory.html">ManageFactory</a></li>
                                <li><a href="../classes/ManageGroupFactory.html">ManageGroupFactory</a></li>
                                <li><a href="../classes/ManageMainController.html">ManageMainController</a></li>
                                <li><a href="../classes/ManageManageableController.html">ManageManageableController</a></li>
                                <li><a href="../classes/ManageManageableDetailController.html">ManageManageableDetailController</a></li>
                                <li><a href="../classes/ManageManageableFactory.html">ManageManageableFactory</a></li>
                                <li><a href="../classes/ovManageSortTable.html">ovManageSortTable</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/ov.manage.html">ov.manage</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: app\client\admin\js\ovManage\DeviceFactory.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

(function(app) {

  /**
   * @module ov.manage
   */

  /**
   * Defines a factory to manage devices.
   *
   * Devices are categorized by state.
   * Either &quot;accepted&quot;, &quot;refused&quot;, &quot;pending&quot; or &quot;incoming&quot;.
   * An &quot;incoming&quot; device is a newly connected device manifesting after retrieving
   * the list of known devices from the server.
   * A &quot;pending&quot; device is a connected device not in server&#x27;s list of known devices.
   *
   * @class ManageDeviceFactory
   * @static
   */
  function DeviceFactory($q,
                          $rootScope,
                          $filter,
                          $timeout,
                          DEVICE_STATES,
                          DEVICE_STATUS,
                          MANAGEABLE_TYPES,
                          TEMPLATES,
                          ManageFactory,
                          ManageableFactory
                         ) {
    var devices = {};
    devices[DEVICE_STATES.INCOMING] = [];

    /**
     * Retrieves a device by its id.
     *
     * Search is made on all devices, accepted, pending, refused and incoming devices.
     *
     * @method getDevice
     * @param {String} id The device id
     * @return {Object|Null} The device or null if not found
     */
    function getDevice(id) {
      var result = null;

      var findDeviceById = function(device) {
        if (device.id === id) result = device;
      };

      if (devices) {
        devices[DEVICE_STATES.ACCEPTED].forEach(findDeviceById);
        devices[DEVICE_STATES.PENDING].forEach(findDeviceById);
        devices[DEVICE_STATES.REFUSED].forEach(findDeviceById);
        devices[DEVICE_STATES.INCOMING].forEach(findDeviceById);
      }

      return result;
    }

    /**
     * Updates device&#x27;s status message depending on its actual status.
     * Device&#x27;s status message is a human readable explanation about the device&#x27;s status.
     *
     * @method updateDeviceStatusMessage
     * @private
     * @param {String} id The device id
     */
    function updateDeviceStatusMessage(id) {
      var device = getDevice(id);

      if (device) {
        switch (device.status) {

          // Device stopped
          case DEVICE_STATUS.STOPPED:
            device.statusMessage = &#x27;MANAGE.STATUS.READY&#x27;;
            break;

          // Device in error
          case DEVICE_STATUS.ERROR:
            device.statusMessage = &#x27;MANAGE.STATUS.ERROR&#x27;;
            break;

          // Device recording session started
          case DEVICE_STATUS.STARTED:
            device.statusMessage = &#x27;MANAGE.STATUS.RECORDING&#x27;;
            break;

          // Device recording session starting
          case DEVICE_STATUS.STARTING:
            device.statusMessage = &#x27;MANAGE.STATUS.STARTING&#x27;;
            break;

          // Device recording session stopping
          case DEVICE_STATUS.STOPPING:
            device.statusMessage = &#x27;MANAGE.STATUS.STOPPING&#x27;;
            break;

          // Device disconnected
          default:
            device.statusMessage = &#x27;MANAGE.STATUS.DISCONNECTED&#x27;;
        }
      }
    }

    /**
     * Adds a device historic.
     *
     * @method addHistoric
     * @param {String} id The device id
     * @param {Object} historic The history
     */
    function addHistoric(id, historic) {
      var device = getDevice(id);
      ManageableFactory.addHistoric(device, historic);
    }

    /**
     * Adds a device schedule.
     *
     * @method addSchedule
     * @param {String} id The device id
     * @param {Object} schedule The schedule
     */
    function addSchedule(id, schedule) {
      var device = getDevice(id);
      ManageableFactory.addSchedule(device, schedule);
    }

    /**
     * Removes a device&#x27;s historic.
     *
     * @method removeHistoric
     * @param {String} id The device id
     * @param {String} historicId The historic id
     */
    function removeHistoric(id, historicId) {
      var device = getDevice(id);
      ManageableFactory.removeHistoric(device, historicId);
    }

    /**
     * Removes a device&#x27;s history.
     *
     * @method removeHistory
     * @param {String} id The device id
     */
    function removeHistory(id) {
      var device = getDevice(id);
      ManageableFactory.removeHistory(device);
    }

    /**
     * Removes a device&#x27;s schedule.
     *
     * @method removeSchedule
     * @param {String} id The device id
     * @param {String} scheduleId The schedule id
     */
    function removeSchedule(id, scheduleId) {
      var device = getDevice(id);
      ManageableFactory.removeSchedule(device, scheduleId);
    }

    /**
     * Adds a new device to the manage interface as a connected device.
     *
     * @method addDevice
     * @param {Object} device The new device description object
     * @param {String} device.id The device&#x27;s id
     * @param {Array} device.history The device&#x27;s history
     * @param {String} device.type The device&#x27;s type
     * @param {String} [device.status] The device&#x27;s status
     * @param {Object} [device.inputs] The device&#x27;s inputs
     * @param {Object} [device.presets] The device&#x27;s presets
     * @param {String} state The device&#x27;s state
     */
    function addDevice(device, state) {
      if (!getDevice(device.id)) {
        var history = device.history;
        device.type = MANAGEABLE_TYPES.DEVICE;
        device.history = [];
        if (!device.status) device.status = DEVICE_STATUS.DISCONNECTED;
        if (!device.inputs) device.inputs = {};
        if (!device.presets) device.presets = [];

        switch (state) {
          case DEVICE_STATES.ACCEPTED:
            devices[DEVICE_STATES.ACCEPTED].push(device);
            break;
          case DEVICE_STATES.REFUSED:
            devices[DEVICE_STATES.REFUSED].push(device);
            break;
          case DEVICE_STATES.PENDING:
            devices[DEVICE_STATES.PENDING].push(device);
            break;
          default:
            devices[DEVICE_STATES.INCOMING].push(device);
        }

        history.forEach(function(historic) {
          addHistoric(device.id, historic);
        });
      }
    }

    /**
     * Gets all devices from server.
     *
     * @method getDevices
     * @return {Promise} A promise resolving with the list of devices categorized
     * by state (either &quot;pending&quot;, &quot;accepted&quot; or &quot;refused&quot;)
     */
    function getDevices() {
      var p = $q.defer();

      if (!devices[DEVICE_STATES.ACCEPTED]) {
        ManageFactory.getDevices().then(function(newDevices) {
          devices[DEVICE_STATES.ACCEPTED] = [];
          devices[DEVICE_STATES.PENDING] = [];
          devices[DEVICE_STATES.REFUSED] = [];
          newDevices.forEach(function(newDevice) {
            switch (newDevice.state) {
              case DEVICE_STATES.ACCEPTED:
                addDevice(newDevice, DEVICE_STATES.ACCEPTED);
                break;
              case DEVICE_STATES.PENDING:
                addDevice(newDevice, DEVICE_STATES.PENDING);
                break;
              case DEVICE_STATES.REFUSED:
                addDevice(newDevice, DEVICE_STATES.REFUSED);
                break;
              default:
                break;
            }
            updateDeviceStatusMessage(newDevice.id);
          });
          p.resolve(devices);
        }, function(error) {
          p.reject(error);
        });
      } else
        p.resolve(devices);

      return p.promise;
    }

    /**
     * Removes a device.
     *
     * @method remove
     * @param {String} id The device id
     * @return {Object} The removed device
     */
    function remove(id) {
      var deviceIndex = -1;
      var deviceCategory = null;
      var device = null;

      var findDevice = function(devices) {
        for (var i = 0; i &lt; devices.length; i++) {
          if (id == devices[i].id) {
            deviceIndex = i;
            deviceCategory = devices;
            device = devices[i];
            return;
          }
        }
      };

      findDevice(devices[DEVICE_STATES.ACCEPTED]);
      findDevice(devices[DEVICE_STATES.PENDING]);
      findDevice(devices[DEVICE_STATES.REFUSED]);
      findDevice(devices[DEVICE_STATES.INCOMING]);

      if (deviceIndex !== -1)
        deviceCategory.splice(deviceIndex, 1);

      return device;
    }

    /**
     * Sets a property on all devices.
     *
     * @method setDevicesProperty
     * @param {String} property The name of the property to set
     * @param {Mixed} value The value for the property
     */
    function setDevicesProperty(property, value) {
      devices[DEVICE_STATES.ACCEPTED].forEach(function(device) {
        device[property] = value;
      });
    }

    /**
     * Updates a device&#x27;s property.
     *
     * @method setProperty
     * @param {String} id The device id
     * @param {String} property The property to modify
     * @param {Mixed} value The property value
     */
    function setProperty(id, property, value) {
      var device = getDevice(id);

      if (device) {
        device[property] = value;

        if (property === &#x27;status&#x27;) {

          if (device.status === DEVICE_STATUS.DISCONNECTED) {

            // Device is now disconnected
            // Remove its volatile information
            delete device.presets;
            delete device.inputs;
            delete device.storage;

            // If the device is not accepted, refused or pending
            // Remove it
            if (device.state === DEVICE_STATES.INCOMING)
              remove(device.id);
          }

          updateDeviceStatusMessage(device.id, device.status);
        }
      }
    }

    /**
     * Validates a device preset confronting its available inputs.
     * Inputs error is available in device.inputs property.
     *
     * @method validatePreset
     * @param {String} deviceId The device id
     * @param {String} presetId The device preset id
     */
    function validatePreset(deviceId, presetId) {
      var device = getDevice(deviceId);

      if (device) {

        // Find device preset
        var preset = ManageableFactory.getPreset(device, presetId);

        if (preset) {

          if ((device.inputs.camera === &#x27;disconnected&#x27; || device.inputs.camera === &#x27;ko&#x27;) &amp;&amp;
              (device.inputs.desktop === &#x27;disconnected&#x27; || device.inputs.desktop === &#x27;ko&#x27;)
          ) {

            // Both camera and desktop are disconnected

            if (preset.parameters.template === TEMPLATES.CAMERA_ONLY &amp;&amp; !preset.parameters[&#x27;rich-media&#x27;])
              device.inputs.error = &#x27;MANAGE.DEVICE.INPUTS_STATUS.MISSING_CAMERA&#x27;;
            else if (preset.parameters.template === TEMPLATES.PC_ONLY)
              device.inputs.error = &#x27;MANAGE.DEVICE.INPUTS_STATUS.MISSING_PC&#x27;;
            else
              device.inputs.error = &#x27;MANAGE.DEVICE.INPUTS_STATUS.MISSING_PC_AND_CAMERA&#x27;;

            return;

          } else if (device.inputs.camera === &#x27;disconnected&#x27; || device.inputs.camera === &#x27;ko&#x27;) {

            // Camera disconnected but not PC

            if (preset.parameters.template !== TEMPLATES.PC_ONLY) {
              device.inputs.error = &#x27;MANAGE.DEVICE.INPUTS_STATUS.MISSING_CAMERA&#x27;;
              return;
            }

          } else if (device.inputs.desktop === &#x27;disconnected&#x27; || device.inputs.desktop === &#x27;ko&#x27;) {

            // PC disconnected but not camera

            if (preset.parameters.template !== TEMPLATES.CAMERA_ONLY || preset.parameters[&#x27;rich-media&#x27;]) {
              device.inputs.error = &#x27;MANAGE.DEVICE.INPUTS_STATUS.MISSING_PC&#x27;;
              return;
            }

          }

          device.inputs.error = null;

        }

      }

    }

    /**
     * Updates a device&#x27;s state.
     *
     * @method updateDeviceState
     * @param {String} id The updated device id
     * @param {String} newState The new state of the device
     */
    function updateDeviceState(id, newState) {

      // Remove device from its category (&quot;accepted&quot;, &quot;pending&quot; or &quot;refused&quot;)
      var device = remove(id);

      // Add device to its new category
      if (device) {
        device.state = newState;

        if (newState === DEVICE_STATES.ACCEPTED)
          devices[DEVICE_STATES.ACCEPTED].push(device);
        else
          devices[DEVICE_STATES.REFUSED].push(device);
      }
    }

    /**
     * Gets devices corresponding to the given state.
     *
     * @method getDevicesByState
     * @param {String} state The state to look for
     * @return {Array} The list of devices
     */
    function getDevicesByState(state) {
      return devices[state];
    }

    /**
     * Checks if a schedule is not in collision with other schedules.
     *
     * Device schedule should not be in collision with device&#x27;s group schedules if inside the group.
     *
     * @method isValidSchedule
     * @param {String} id The device id
     * @param {Object} schedule The schedule to validate
     * @param {Object} [group] The device&#x27;s group
     * @param {Array} [group.schedules] The group&#x27;s schedules
     * @return {Error|Null} The error if validation failed, null otherwise
     */
    function isValidSchedule(id, schedule, group) {
      var device = getDevice(id);

      if (device) {
        var validationError = ManageableFactory.isValidSchedule(schedule, device.schedules);
        if (validationError) return validationError;

        if (group) {

          // Validate that the schedule is not in conflict with one of the schedules in the device&#x27;s group
          for (var i = 0; i &lt; group.schedules.length; i++) {
            if (ManageableFactory.checkSchedulesConflict(group.schedules[i], schedule))
              return new Error($filter(&#x27;translate&#x27;)(&#x27;MANAGE.MANAGEABLE.GROUP_CONFLICT_ERROR&#x27;));
          }

        }

      }

      return null;
    }

    /**
     * Checks if there are collisions between device&#x27;s schedules and group&#x27;s schedules.
     *
     * @method isGroupSchedulesCollision
     * @param {String} id The device id
     * @param {Object} group The group
     * @param {Array} [group.schedules] The group&#x27;s schedules
     * @return {Boolean} true if there is at least one collision, false otherwise
     */
    function isGroupSchedulesCollision(id, group) {
      var device = getDevice(id);

      if (device &amp;&amp; group) {
        for (var i = 0; i &lt; device.schedules.length; i++) {
          var deviceSchedule = device.schedules[i];

          // Validate that the schedule is not in conflict with one of the schedules in the group
          for (var j = 0; j &lt; group.schedules.length; j++) {
            if (ManageableFactory.checkSchedulesConflict(group.schedules[j], deviceSchedule))
              return true;
          }

        }
      }

      return false;
    }

    return {
      getDevices: getDevices,
      getDevice: getDevice,
      remove: remove,
      setDevicesProperty: setDevicesProperty,
      setProperty: setProperty,
      updateDeviceState: updateDeviceState,
      addDevice: addDevice,
      getDevicesByState: getDevicesByState,
      addHistoric: addHistoric,
      addSchedule: addSchedule,
      removeHistoric: removeHistoric,
      removeHistory: removeHistory,
      removeSchedule: removeSchedule,
      validatePreset: validatePreset,
      isValidSchedule: isValidSchedule,
      isGroupSchedulesCollision: isGroupSchedulesCollision
    };

  }

  app.factory(&#x27;ManageDeviceFactory&#x27;, DeviceFactory);
  DeviceFactory.$inject = [
    &#x27;$q&#x27;,
    &#x27;$rootScope&#x27;,
    &#x27;$filter&#x27;,
    &#x27;$timeout&#x27;,
    &#x27;MANAGE_DEVICE_STATES&#x27;,
    &#x27;MANAGE_DEVICE_STATUS&#x27;,
    &#x27;MANAGE_MANAGEABLE_TYPES&#x27;,
    &#x27;MANAGE_TEMPLATES&#x27;,
    &#x27;ManageFactory&#x27;,
    &#x27;ManageManageableFactory&#x27;
  ];

})(angular.module(&#x27;ov.manage&#x27;));

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
